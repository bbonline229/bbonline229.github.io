{"title":"[Swift] Closure in Swift 5 - Part 3 (Escape Closure)","date":"2019-05-23T02:48:58.000Z","link":"2019/05/23/closure3","comments":true,"tags":["swift"],"updated":"2019-09-25T04:36:37.892Z","content":"<p><img src=\"/2019/05/23/closure3/fetchData.png\" alt class=\"article-img\"></p>\n<p><code>@escaping</code> 這個關鍵字在寫 iOS app 時應該多少都會遇到<br>遇到時會出現 warning, 按下 fix , 系統都會自動幫你在 function 內的 closure 參數前面添加 <code>@escaping</code> 這個關鍵字</p>\n<br>\n\n<h1 id=\"什麼情況需要加上-escaping-關鍵字？\">什麼情況需要加上 <code>@escaping</code> 關鍵字？<a href=\"2019/05/23/closure3#什麼情況需要加上-escaping-關鍵字？\"></a></h1><p>先來看一下官方文檔</p>\n<blockquote>\n<p>A closure is said to escape a function when the closure is passed as an argument to the function, but is called after the function returns. </p>\n<p>When you declare a function that takes a closure as one of its parameters, you can write @escaping before the parameter’s type to indicate that the closure is allowed to escape. </p>\n</blockquote>\n<p><strong>當一個 closure 被當參數傳入時, 它在 function 執行結束後才被呼叫</strong><br>這個 closure 就稱為 <code>Escape Closure (可逃脫)</code></p>\n<p>Swift3 開始, closure 被當參數傳入預設都是 non-escaping 也就是 closure 預設不可逃脫<br><strong>如果這個 closure 是 <code>Escape Closure</code> 就必須加上 <code>@escaping</code> 關鍵字來允許 closure 是可逃脫</strong></p>\n<h2 id=\"情況一-Non-escape-closure\">情況一 (Non-escape closure)<a href=\"2019/05/23/closure3#情況一-Non-escape-closure\"></a></h2><figure class=\"highlight swift\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">sayHello</span><span class=\"params\">(excute: <span class=\"params\">()</span></span></span> -&gt; <span class=\"type\">Void</span>) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    excute() <span class=\"comment\">// 1. print \"Hello Closure.\"</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">\"Function has been return !!! \"</span>) <span class=\"comment\">// 2. print \"Function has been return.\"</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">sayHello &#123;</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">\"Hello Closure !!!\"</span>)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></div></figure>\n\n<p><img src=\"/2019/05/23/closure3/store.png\" alt class=\"article-img\"></p>\n<p><strong>很明顯的傳入的 closure 會在 function return 之前 就執行結束<br>所以會先執行 <code>print(&quot;Hello Closure !!!&quot;)</code> 後<br>才執行<code>print(&quot;Function has been return !!! &quot;)</code><br>這種情況就不用加上 <code>@escaping</code> 關鍵字</strong><br><br></p>\n<h2 id=\"情況二-Escape-closure\">情況二 (Escape closure)<a href=\"2019/05/23/closure3#情況二-Escape-closure\"></a></h2><p><mark><strong>將 closure 儲存在另一個變數</strong></mark></p>\n<figure class=\"highlight swift\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> sayHello: (() -&gt; <span class=\"type\">Void</span>)!</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">saySomething</span><span class=\"params\">(excute: @escaping <span class=\"params\">()</span></span></span> -&gt; <span class=\"type\">Void</span>) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    sayHello = excute</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">\"Function has been return !!! \"</span>) <span class=\"comment\">// 1. print \"Function has been return.\"</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">saySomething &#123;</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">\"Hello Closure !!!\"</span>)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// sayHello不知道啥時會執行</span></span><br><span class=\"line\"><span class=\"comment\">// sayHello() // 2. print \"Hello Closure\"</span></span><br></pre></td></tr></table></div></figure>\n\n<p><img src=\"/2019/05/23/closure3/store2.png\" alt class=\"article-img\"></p>\n<figure class=\"highlight swift\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sayHello() <span class=\"comment\">// 2. print \"Hello Closure\"</span></span><br></pre></td></tr></table></div></figure>\n\n<p><img src=\"/2019/05/23/closure3/store3.png\" alt class=\"article-img\"></p>\n<p><strong>這種情況因為 closure 儲存在一個變數中, 根本不知道何時會執行<br>有可能會在 function 執行完之後才執行<br>所以系統會強迫加上 <code>@escaping</code> 關鍵字<br>範例是 function 執行完了, 才呼叫<br>所以會先執行 <code>print(&quot;Function has been return&quot;)</code> 後<br>才執行<code>print(&quot;Hello Closure !!!&quot;)</code></strong><br><br></p>\n<h2 id=\"情況三-Escape-closure\">情況三 (Escape closure)<a href=\"2019/05/23/closure3#情況三-Escape-closure\"></a></h2><p><mark><strong>比較常見的就是一些非同步(Asynchronous)的任務, 例如：網路請求, 延遲…等</strong></mark></p>\n<h4 id=\"1-延遲執行-closure\">1. 延遲執行 closure<a href=\"2019/05/23/closure3#1-延遲執行-closure\"></a></h4><figure class=\"highlight swift\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 加入 @escaping關鍵字允許 closure 逃脫</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">sayHello</span><span class=\"params\">(excute: @escaping <span class=\"params\">()</span></span></span>-&gt;<span class=\"type\">Void</span>) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 延遲三秒</span></span><br><span class=\"line\">    <span class=\"type\">DispatchQueue</span>.main.asyncAfter(deadline:.now() + <span class=\"number\">3</span>)&#123;</span><br><span class=\"line\">        excute() <span class=\"comment\">// 2. print \"Hello closure.\"</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">\"Function has been return !!! \"</span>) <span class=\"comment\">// 1. print \"Function has been return.\"</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\">sayHello &#123;</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">\"Hello Closure\"</span>)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></div></figure>\n\n<p><img src=\"/2019/05/23/closure3/delay.png\" alt class=\"article-img\"></p>\n<p><strong>遇到有 asynchronous 的任務時, 一定是要加 <code>@escaping</code> 關鍵字<br>這類的任務幾乎都是會花一定的時間執行<br>asynchronous 的任務會跳到其他的 thread 去執行<br>所以會先執行<code>print(&quot;Function has been return&quot;)</code>後, 才<br>執行 <code>print(&quot;Hello Closure&quot;)</code></strong><br><br></p>\n<h4 id=\"2-網路請求-completion-handler\">2. 網路請求 (completion handler)<a href=\"2019/05/23/closure3#2-網路請求-completion-handler\"></a></h4><figure class=\"highlight swift\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 加入 @escaping關鍵字允許 Closure 逃脫</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> url = <span class=\"type\">URL</span>(string: <span class=\"string\">\"https://apple.com\"</span>)!</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">fetchData</span><span class=\"params\">(with url: URL, completion: @escaping <span class=\"params\">()</span></span></span> -&gt; <span class=\"type\">Void</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> task = <span class=\"type\">URLSession</span>.shared.dataTask(with: url) &#123; (data, urlresponse, error) <span class=\"keyword\">in</span></span><br><span class=\"line\">        completion()</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    task.resume()</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">\"Function has been return !!!\"</span>) <span class=\"comment\">// 1. print \"function return\"</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">fetchData(with: url) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">\"Download Complete !!!\"</span>) <span class=\"comment\">//2. print \"Download Complete\"</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></div></figure>\n\n<p><img src=\"/2019/05/23/closure3/fetchData2.png\" alt class=\"article-img\"></p>\n<p><strong>網路請求也是 asynchronous 的任務, 會跳到其他 thread 去執行長時間任務<br>執行完才會呼叫 closure, 這時 function 早就先執行完了<br>所以也是要加上 <code>@escaping</code> 關鍵字</strong></p>\n<br>\n\n<h2 id=\"結論：\">結論：<a href=\"2019/05/23/closure3#結論：\"></a></h2><p><mark><strong>Non-escape 跟 escape 的差異點就在於 closure 存活的生命週期而已</strong></mark><br><strong>前者只侷限在 function 內執行, function 執行結束, closure 生命週期也跟著結束</strong><br><strong>後者則是可允許 closure 在 function 執行結束後才被呼叫</strong><br><strong><del>其實不懂好像也沒差, 畢竟編譯器會自動幫你補上 <code>@escaping</code> 關鍵字ＸＤ</del></strong></p>\n","prev":{"title":"[iOS] RxSwift 簡易筆記","link":"2019/07/16/rxswift"},"next":{"title":"[Swift] Closure in Swift 5 - Part 2 (使用高階函數)","link":"2019/05/20/closure2"},"plink":"http://yoursite.com/2019/05/23/closure3/","toc":[{"title":"什麼情況需要加上 <code>@escaping</code> 關鍵字？","id":"什麼情況需要加上-escaping-關鍵字？","index":"1","children":[{"title":"情況一 (Non-escape closure)","id":"情況一-Non-escape-closure","index":"1.1"},{"title":"情況二 (Escape closure)","id":"情況二-Escape-closure","index":"1.2"},{"title":"情況三 (Escape closure)","id":"情況三-Escape-closure","index":"1.3"},{"title":"結論：","id":"結論：","index":"1.4"}]}]}